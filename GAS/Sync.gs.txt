/**
 * ERM FISIOTA BACKEND - V5.0 (MODULAR)
 * FILE: 2_Sync.gs
 * Deskrpsi: Fungsi Helper untuk sinkronisasi data (Read/Write Sheet).
 */

var TARGET_SHEET_ID = ""; // Global variable for dynamic targeting

function getSpreadsheet() {
    if (TARGET_SHEET_ID) {
        try {
            return SpreadsheetApp.openById(TARGET_SHEET_ID);
        } catch (e) {
            console.error("Failed to open target sheet: " + TARGET_SHEET_ID);
            throw new Error("Gagal membuka Sheet Klien. Pastikan Sheet sudah DISHARE ke email script ini.");
        }
    }
    return SHEET_ID ? SpreadsheetApp.openById(SHEET_ID) : SpreadsheetApp.getActiveSpreadsheet();
}

function getOrInsertSheet(ss, name, headers) {
    let sheet = ss.getSheetByName(name);
    if (!sheet) {
        sheet = ss.insertSheet(name);
        sheet.appendRow(headers);
        sheet.getRange(1, 1, 1, headers.length).setFontWeight("bold").setBackground("#dbeafe");
    }
    return sheet;
}

function getDataFromSheet(ss, sheetName) {
    const sheet = ss.getSheetByName(sheetName);
    if (!sheet) return [];
    const rows = sheet.getDataRange().getValues();
    if (rows.length < 2) return [];
    const headers = rows[0];
    const data = rows.slice(1);
    return data.map(row => {
        let obj = {};
        headers.forEach((h, i) => {
            let val = row[i];
            if (h === 'date' || h === 'dob' || h === 'created_at' || h === 'updatedAt' || h === 'paidAt') val = (val instanceof Date) ? Utilities.formatDate(val, TIMEZONE, "yyyy-MM-dd") : val;
            if (h === 'time') val = (val instanceof Date) ? Utilities.formatDate(val, TIMEZONE, "HH:mm") : val;
            obj[h] = val;
        });
        return obj;
    });
}

function saveDataFixed(ss, name, data, headers) {
    let sheet = getOrInsertSheet(ss, name, headers);
    if (sheet.getLastRow() > 1) sheet.getRange(2, 1, sheet.getLastRow() - 1, sheet.getLastColumn()).clearContent();
    if (!data || data.length === 0) return;
    const rows = data.map(item => headers.map(k => {
        let v = item[k];
        return (typeof v === 'object') ? JSON.stringify(v) : (v || "");
    }));
    sheet.getRange(2, 1, rows.length, headers.length).setNumberFormat("@").setValues(rows);
}

function updateConfigSheet(ss, configData) {
    let sheet = getOrInsertSheet(ss, SHEET_NAMES.CONFIG, HEADERS.CONFIG);
    const map = new Map();
    sheet.getDataRange().getValues().slice(1).forEach((r, i) => map.set(r[0], i + 2));

    configData.forEach(c => {
        const time = new Date();
        if (map.has(c.key)) {
            const row = map.get(c.key);
            sheet.getRange(row, 2).setValue(c.value);
            sheet.getRange(row, 3).setValue(time);
        } else {
            sheet.appendRow([c.key, c.value, time]);
        }
    });
}


function processIncrementalSync(ss, changes) {
    const merge = (sheetName, headers, incomingItems) => {
        if (!incomingItems || incomingItems.length === 0) return;

        const sheet = getOrInsertSheet(ss, sheetName, headers);
        const dataRange = sheet.getDataRange();
        const values = dataRange.getValues();

        // 1. If map is empty (only has headers or nothing), just append all
        if (values.length <= 1) {
            const newRows = incomingItems.map(item => headers.map(k => {
                let v = item[k];
                return (typeof v === 'object') ? JSON.stringify(v) : (v || "");
            }));
            sheet.getRange(2, 1, newRows.length, headers.length).setNumberFormat("@").setValues(newRows);
            return;
        }

        // 2. Map existing IDs to their row INDEX (in the 'values' array)
        // headers are at index 0. Data starts at index 1.
        const idMap = new Map();
        // values[i][0] is the ID column (Assuming 'id' is always first in headers)
        for (let i = 1; i < values.length; i++) {
            idMap.set(String(values[i][0]), i);
        }

        const newRows = [];
        let updatedCount = 0;

        // 3. Process incoming items
        incomingItems.forEach(item => {
            const id = String(item.id);
            const rowData = headers.map(k => {
                let v = item[k];
                return (typeof v === 'object') ? JSON.stringify(v) : (v || "");
            });

            if (idMap.has(id)) {
                // Update in-memory array
                const rowIndex = idMap.get(id);
                values[rowIndex] = rowData;
                updatedCount++;
            } else {
                // Collect new rows
                newRows.push(rowData);
            }
        });

        // 4. Batch Write Back
        // Write updated existing rows (from values) + new rows
        // We write the ENTIRE updated data set to ensure consistency
        // (This is still faster than appendRow loop, and cheaper than cell-by-cell update)

        let finalData = values.slice(1); // Remove header from existing data
        if (newRows.length > 0) finalData = finalData.concat(newRows);

        // Clear content and write fresh
        if (finalData.length > 0) {
            // Optimization: Limit range clearing to used area
            // But safest is to clear old content first to avoid artifacts if total rows shrunk (unlikely in sync, but good practice)
            // Actually, for INCREMENTAL sync, the total rows never shrink effectively (we don't handle deletions here yet, or 'rewriting' handles it).
            // Since we are merging, the list only grows or stays same size (updates).

            sheet.getRange(2, 1, finalData.length, headers.length).setNumberFormat("@").setValues(finalData);
        }
    };

    if (changes.patients) merge(SHEET_NAMES.PATIENTS, HEADERS.PATIENTS, changes.patients);
    if (changes.assessments) merge(SHEET_NAMES.ASSESSMENTS, HEADERS.ASSESSMENTS, changes.assessments);
    if (changes.appointments) merge(SHEET_NAMES.APPOINTMENTS, HEADERS.APPOINTMENTS, changes.appointments);
    if (changes.expenses) merge(SHEET_NAMES.EXPENSES, HEADERS.EXPENSES, changes.expenses);
    if (changes.packages) merge(SHEET_NAMES.PACKAGES, HEADERS.PACKAGES, changes.packages);
    if (changes.config) updateConfigSheet(ss, changes.config);

    // Handle Deletions
    if (changes.deletedIds) {
        const del = changes.deletedIds;
        if (del.patients && del.patients.length > 0) deleteRowsById(ss.getSheetByName(SHEET_NAMES.PATIENTS), del.patients);
        if (del.assessments && del.assessments.length > 0) deleteRowsById(ss.getSheetByName(SHEET_NAMES.ASSESSMENTS), del.assessments);
        if (del.appointments && del.appointments.length > 0) deleteRowsById(ss.getSheetByName(SHEET_NAMES.APPOINTMENTS), del.appointments);
        if (del.expenses && del.expenses.length > 0) deleteRowsById(ss.getSheetByName(SHEET_NAMES.EXPENSES), del.expenses);
        if (del.packages && del.packages.length > 0) deleteRowsById(ss.getSheetByName(SHEET_NAMES.PACKAGES), del.packages);
    }
}

function deleteRowsById(sheet, ids) {
    if (!sheet || !ids || ids.length === 0) return;
    const data = sheet.getDataRange().getValues();
    const rowsToDelete = [];

    // Search from bottom to top to avoid index shifts
    for (let i = data.length - 1; i >= 1; i--) {
        if (ids.indexOf(String(data[i][0])) !== -1) {
            sheet.deleteRow(i + 1);
        }
    }
}

function createJSONOutput(obj) { return ContentService.createTextOutput(JSON.stringify(obj)).setMimeType(ContentService.MimeType.JSON); }

// --- AUTO-UPDATE COLUMNS FEATURE ---
function checkAndFixColumns(ss, isMaster = false) {
    const allSheets = [
        { name: SHEET_NAMES.PATIENTS, headers: HEADERS.PATIENTS },
        { name: SHEET_NAMES.ASSESSMENTS, headers: HEADERS.ASSESSMENTS },
        { name: SHEET_NAMES.APPOINTMENTS, headers: HEADERS.APPOINTMENTS },
        { name: SHEET_NAMES.CONFIG, headers: HEADERS.CONFIG },
        { name: SHEET_NAMES.EXPENSES, headers: HEADERS.EXPENSES },
        { name: SHEET_NAMES.PACKAGES, headers: HEADERS.PACKAGES },
        { name: SHEET_NAMES.LICENSES, headers: HEADERS.LICENSES }
    ];

    // Filter: Jika isMaster, hanya proses Licenses. Jika tidak, proses semua selain Licenses.
    const sheetsToCheck = allSheets.filter(item => {
        if (isMaster) return item.name === SHEET_NAMES.LICENSES;
        return item.name !== SHEET_NAMES.LICENSES;
    });

    let logs = [];

    sheetsToCheck.forEach(item => {
        const sheet = ss.getSheetByName(item.name);
        if (!sheet) {
            logs.push(`[${item.name}] Tab tidak ditemukan. Menambah tab baru.`);
            getOrInsertSheet(ss, item.name, item.headers);
            return;
        }

        const lastCol = sheet.getLastColumn();
        const currentHeadersRaw = lastCol > 0 ? sheet.getRange(1, 1, 1, lastCol).getValues()[0] : [];
        
        // Normalisasi header yang ada (lowercase + hapus spasi & underscore)
        const normalize = (s) => String(s).toLowerCase().replace(/[\s_]/g, "");
        const currentHeadersNormalized = currentHeadersRaw.map(normalize);

        const missingHeaders = item.headers.filter(h => !currentHeadersNormalized.includes(normalize(h)));

        if (missingHeaders.length > 0) {
            const startCol = lastCol + 1;
            sheet.getRange(1, startCol, 1, missingHeaders.length)
                .setValues([missingHeaders])
                .setFontWeight("bold")
                .setBackground("#dbeafe");
            
            logs.push(`[${item.name}] Menambah kolom: ${missingHeaders.join(', ')}`);
        } else {
            logs.push(`[${item.name}] Ok.`);
        }
    });

    return logs;
}
